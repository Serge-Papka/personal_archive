Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют
 ассоциативными массивами или хеш-таблицами.

У словаря есть метод items(dict.items()), который возвращает кортежи, состоящие из пар ключ-значение. Зная их, можно вывести статистику по тексту.
-----------------
d = {2 : "c", 1 : "d", 4 : "a", 3 : "b"}
# Чтобы отсортировать его по ключам, нужно сделать так
print(dict(sorted(d.items())))
# {1: 'd', 2: 'c', 3: 'b', 4: 'a'}
---
sorted(d.items(), key=lambda x: x[1])  # сортировка по значению словаря
-----------------
dict['Ключ']- возвращает значение этого ключа

dict.clear() - очищает словарь.
dict.copy() - возвращает копию словаря.
classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).
dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).
dict.items() - возвращает пары (ключ, значение).
dict.keys() - возвращает ключи в словаре.
dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).
dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).
dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
dict.values() - возвращает значения в словаре.


d = {a: a ** 2 for a in range(7)}
print (d)

>>> d = {}
>>> d
{}
>>> d = {'dict': 1, 'dictionary': 2}
>>> d
{'dict': 1, 'dictionary': 2}
Во-вторых, с помощью функции dict:

>>>
>>> d = dict(short='dict', long='dictionary')
>>> d
{'short': 'dict', 'long': 'dictionary'}
>>> d = dict([(1, 1), (2, 4)])
>>> d
{1: 1, 2: 4}
В-третьих, с помощью метода fromkeys:

>>>
>>> d = dict.fromkeys(['a', 'b'])
>>> d
{'a': None, 'b': None}
>>> d = dict.fromkeys(['a', 'b'], 100)
>>> d
{'a': 100, 'b': 100}
В-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.

>>>
>>> d = {a: a ** 2 for a in range(7)}
>>> d
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
Теперь попробуем добавить записей в словарь и извлечь значения ключей:

>>>
>>> d = {1: 2, 2: 4, 3: 9}
>>> d[1]
2
>>> d[4] = 4 ** 2
>>> d
{1: 2, 2: 4, 3: 9, 4: 16}
>>> d['1']
Traceback (most recent call last):
  File "", line 1, in
    d['1']
KeyError: '1'

----------------------
"""
Модифицируйте функцию проверки баланса скобок для двух видов скобок: круглых и квадратных.
Для реализации такого алгоритма может быть полезным создание словаря, в котором закрывающая скобка — ключ,
открывающая — значение.
"""


def par_checker(string):
    stack = []  # инициализируем стек
    dict_ = {')': '(', ']': '['}
    # print(dict_.values())

    for s in string:  # читаем строку посимвольно
        if s in dict_.values():  # если открывающая скобка,
            stack.append(s)  # добавляем её в стек
        elif s in dict_.keys():
            # если встретилась закрывающая скобка, то проверяем,
            # пуст ли стек и является ли верхний элемент открывающей скобкой
            if len(stack) > 0 and stack[-1] == dict_[s] :
                stack.pop()  # удаляем из стека
            else:  # иначе завершаем функцию с False
                return False
    # если стек пустой, то незакрытых скобок не осталось
    # значит возвращаем True, иначе - False
    return len(stack) == 0


print(par_checker("(5+6)*(7+8)/(4+3)"))
